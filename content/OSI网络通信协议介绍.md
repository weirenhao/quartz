---
share: "true"
date: 2024-12-02 09:45
updated: 2024-12-03 15:56
---

# [网络通信协议-基础中的基础](https://www.cnblogs.com/the3times/p/12724602.html "发布于 2020-04-18 10:53")

## CS架构&BS架构

```python
# 互联通信软件有两种模式：CS架构和BS架构
CS指的是Client-Server，分别有一个客户端软件和一个服务端软件
BS指的是Browser-Server，一个浏览器和一个服务端软件

客户端软件send                 服务端软件recv
操作系统                       操作系统
计算机硬件 <====物理介质=====>  计算机硬件
```

## 网络通信

网络 = 物理链接介质 + 互联网通信协议

```python
网络存在的意义就是跨地域数据传输, 称之为通信
互联网的本质就是一系列的网络协议
互联网协议的功能：定义计算机如何接入internet，以及接入internet的计算机通信的标准。
```

## 体系结构

把计算机网络的各层及其协议的集合，称为网络的体系结构。

互联网通信协议更具历史的发展分别有：osi七层协议、TCP/IP四层协议、TCP/IP五层协议

![](https://img-blog.csdnimg.cn/20190402172335740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgzODU3Ng==,size_16,color_FFFFFF,t_70)

- OSI七层协议是国际标准化组织ISO提出的，但由于是市场原因和该协议本身的缺点（协议实现过一复杂，层次划分不太合理等）导致起初市场上大规模使用的并不是该协议，而是因特网。所以有这样一个现象：得到最广泛应用的不是法律上的国际标准OSI，而是非国际标准TCP/IP。这样TCP/IP成为了事实上的国际标准。
- OSI七层协议体系结构的概念清楚，理论也比较完整，但它既复杂又不实用。TCP/IP体系结构则不同，它现在已经得到了非常广泛的应用。TCP/IP是一个四层的体系结构。因为最下面的网络接口层基本上和一般的通信链路在功能上没有多大区别，对于计算机网络来说，这一层并没有特别新的具体内容。因此在在学习计算机网络的原理是往往采取折中的办法，即综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构，遮掩既简洁又能将概念阐述清楚。
- TCP/IP代表传输控制协议/网际协议，指的是一系列协组。

```python
# 协议：规定数据的组织格式
# 格式：头部 + 数据部分
```

---

## 物理层

物理层由来：上面提到，孤立的计算机之间要想一起玩，就必须接入internet，言外之意就是计算机之间必须完成组网。

![image.png](https://raw.githubusercontent.com/weirenhao/friendly-image/master/20241202094241.png)

物理层功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0

```python
# 一组物理层数据称之为：位
# 单纯的电信号毫无意义，必须对其进行分组
```

---

## 数据链路层

数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思

数据链路层的功能：定义了电信号的分组方式

数据链路层：遵循以太网协议（ethernet）

```python
规定1：一组数据称之为一个数据帧
规定2：数据帧分成两部分=》头+数据
    头包含：源地址与目标地址，该地址是mac地址
    数据包含：包含的是网络层发过来的整体的内容

规定3：规定但凡接入互联网的主机必须有一块网卡，每块网卡在出厂时都烧制好一个全世界独一无二的地址，该地址称之为mac地址

head包含：(固定18个字节)
发送者／源地址，6个字节
接收者／目标地址，6个字节
数据类型，6个字节
data包含：(最短46字节，最长1500字节)

数据包的具体内容
head长度＋data长度＝最短64字节，最长1518字节，超过最大限制就分片发送

head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址
mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）
```

有了mac地址，同一网络内的两台主机就可以通信了（一台主机通过arp协议获取另外一台主机的mac地址）

ethernet采用最原始的方式，**广播的方式进行通信，即计算机通信基本靠吼**。

---

## 网络层

**网络层的目的是划分广播域。**

```python
网络层由来：有了ethernet、mac地址、广播的发送方式，世界上的计算机就可以彼此通信了，问题是世界范围的互联网是由
一个个彼此隔离的小的局域网组成的，那么如果所有的通信都采用以太网的广播方式，那么一台机器发送的包全世界都会收到，这就不仅仅是效率低的问题了，这会是一种灾难.
必须找出一种方法来区分哪些计算机属于同一广播域，哪些不是，如果是就采用广播的方式发送，如果不是，
就采用路由的方式（向不同广播域／子网分发数据包），mac地址是无法区分的，它只跟厂商有关
```

每一个广播域但凡要接通外部，一定要有一个网关帮内部的计算机转发包到公网。网关与外界通信走的是路由协议。

网络层功能：引入一套新的地址用来区分不同的广播域／子网，这套地址即网络地址（IP地址）。

**网络层：遵循IP协议**

**IP协议：**

- 规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示
- 范围0.0.0.0-255.255.255.255
- 一个ip地址通常写成四段十进制数，例：172.16.10.1

```python
规定1：一组数据称之为一个数据包
规定2：数据帧分成两部分=》头+数据
    头包含：源地址与目标地址，该地址是IP地址
    数据包含的：传输层发过来的整体的内容
```

**ip地址分成两部分**

- 网络部分：标识子网
- 主机部分：标识主机

注意：单纯的ip地址段只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网

例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网

**子网掩码**

所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。

```python
子网掩码：它的书写方式和ip地址的形式相同。也可以写成多少个1，即24表示前面24个1，后面8位0，如果不写，默认是24
zip地址要配合子网掩码一块使用才有意义
```

知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。

将IP地址和子网掩码都换算成二进制，然后进行与运算，结果就是网络地址。网络地址相同则在一个局域网内。

```python
# 判断两个IP地址是否处于一个自网络内：
将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同。
如果是的话，就表明它们在同一个子网络中，否则就不是。
# 应用：
已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？
两者与子网掩码分别进行AND运算，

172.16.10.1：10101100.00010000.00001010.000000001
255255.255.255.0:11111111.11111111.11111111.00000000
AND运算得网络地址结果：10101100.00010000.00001010.000000001  -->  172.16.10.0

172.16.10.2：10101100.00010000.00001010.000000010
255255.255.255.0:11111111.11111111.11111111.00000000
AND运算得网络地址结果：10101100.00010000.00001010.000000001  -->  172.16.10.0
结果都是172.16.10.0，因此它们在同一个子网络。
```

总结一下，IP协议的作用主要有两个：

- 一个是为每一台计算机分配IP地址
- 另一个是确定哪些地址在同一个子网络。

**ip数据包**

```python
# ip数据包也分为head和data部分，无须为ip包定义单独的栏位，直接放入以太网包的data部分
head：长度为20到60字节
data：最长为65,515字节。
而以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了
```

**ARP协议**

arp协议由来：计算机通信基本靠吼，即广播的方式，所有上层的包到最后都要封装上以太网头，然后通过以太网协议发送，在谈及以太网协议时候，我们了解到通信是基于mac的广播方式实现，计算机在发包时，获取自身的mac是容易的，**如何获取目标主机的mac，就需要通过arp协议**。

arp协议功能：广播的方式发送数据包，获取目标主机的mac地址

协议工作方式：每台主机ip都是已知的

例如：主机172.16.10.10/24访问172.16.10.11/24

一：首先通过ip地址和子网掩码区分出自己所处的子网

| 场景   | 数据包地址          |
| ---- | -------------- |
| 同一子网 | 目标主机mac，目标主机ip |
| 不同子网 | 网关mac，目标主机ip   |

二：分析172.16.10.10/24与172.16.10.11/24处于同一网络(如果不是同一网络，那么下表中目标ip为172.16.10.1，通过arp获取的是网关的mac)

|       | 源mac   | 目标mac             | 源ip             | 目标ip            | 数据部分 |
| ----- | ------ | ----------------- | --------------- | --------------- | ---- |
| 发送端主机 | 发送端mac | FF:FF:FF:FF:FF:FF | 172.16.10.10/24 | 172.16.10.11/24 | 数据   |

三：这个包会以广播的方式在发送端所处的自网内传输，所有主机接收后拆开包，发现目标ip为自己的，就响应，返回自己的mac

```python
很容易知道目标主机的ip地址/子网掩码，通过ip地址/子网掩码的位运算(逻辑与)就可以判断通信双方是否在一个局域网内。
# 相同局域网内的主机通信
知道目标主机的ip地址，通过广播的方式在局域网发送数据。
发送数据前，通过arp协议可以获悉对方主机的mac地址。
这个arp协议是局域网内的每个主机ip地址和mac地址映射关系表。
每个主机的ip地址
```

## 数据传输流程总结1

- <1> 网络层拿到上层传过来的数据，将数据打包，加一个ip头。这个ip头至少包含两部分（我的ip和对方主机的ip，ip包含子网掩码）
- <2> 将打包好ip头的数据传给下一层的数据链路层前会做一个判断，判断对方主机的ip和我自己的ip是不是在一个局域网内。
- <3> 判断的方式：ip和子网掩码做一个逻辑与的位运算。计算后的结果相等则表示在一个局域网内，否则对方主机不在当前局域网内。
- <4> 当两台主机在一个局域网内，此时会自动触发arp协议执行。通过广播的方式发一个arp包，就会获取局域网内的对方主机的mac地址。ARP协议是建立在各个主机之间信任的基础之上的，收到消息后发现arp包里面是自己的ip就会将mac地址响应给发送arp协议的主机，如果包里面的ip不是自己就将包丢掉。
- <5> 拿到对方主机mac地址后，此时就到了数据链路层，将网络层传过来的数据整体打包，加一个以太网的头。这个头主要包含两个数据，自己的mac地址和对方主机的mac地址。通过广播的方式将数据发出去。
- <6> 然后经过物理层将数据转为二进制，通过网线传输出去，此时就会经过二层交换机，二层交换机可以将数据包解开到数据链路层，发现里面对方主机的mac地址，然后就知道将数据包交给哪台主机了(mac地址记忆功能，不需要再广播)。
- <7> 回到第3步，如果计算后发现两台主机不在一个局域网内，此时也会自动触发arp协议的执行，通过arp协议的数据包将获取当前局域网网关的mac地址。
- <8> 数据下交给数据链路层，打上一个以太网的头，分别是自己的mac地址和当前局域网网关的mac地址。内层ip包里面的头是自己的ip地址和对方主机的ip地址。
- <9> 上面封装好以太网头的数据交给物理层转二进制，再经过二层交换机，再经过网关交到公网的路由系统。路由相当于一个三层交换机，可以解压到网络层，发现里面对方主机的ip地址。
- <10> 路由根据对方主机的ip地址可以映射找到一个子网(另一个局域网)，将数据交给对方子网的网关。对方的网关自动触发arp协议根据对方主机的ip地址找到是哪个mac地址的主机，最终将数据交到对方主机。
- <11> 此时，对方局域网的网关通过路由的mac地址和网关的映射关系就知道了发数据过来的子网网关的mac地址，对方主机也知道了发数据过来的主机的ip地址。这就分别实现了数据链路层的交流通信和网络层的交流通信。

**补充**：

```python
补充1：arp协议只在一个局域网内通过ip解析获取mac地址，不会跨局域网根据ip地址获取主机mac地址。
补充2：局域网内每个主机的ip地址各不相同，这才实现了arp协议根据ip地址解析成mac地址的可能。
补充3：ip地址本质是网络地址加主机地址。通过ip地址可以唯一确定一个机器，因为局域网内每个主机的mac地址不同就会分配不同的ip地址。
```

---

## 传输层

传输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机。但是我们写网络通信软件最主要的是找到目标计算机上的某个软件，上面的mac+ip还不能实现这个需求。这就需要再提出一个端口的概念。端口即应用程序与网卡关联的编号。

**传输层功能：建立端口到端口的通信**

```python
补充：端口范围0-65535，0-1023为系统占用端口
客户端软件的端口号是由操作系统动态分配的。一个机器上的端口号不能冲突。
服务端软件的端口号是绑定的，不能变的。
```

传输层遵循的协议有两个：**TCP协议和UDP协议**，基于端口工作

```python
mac + ip 标识唯一一个主机
ip + port 标识唯一一台主机上的一个基于网络通信的软件
```

tcp头里面放的是源端口和目标端口，udp头也一样。

```python
# tcp协议
可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。
# 至此：数据包装结果
以太网头 --> ip头 --> tcp头 --> 数据   

# udp协议
不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。
# 至此：数据包装结果
以太网头 --> ip头 --> udp头 --> 数据
```

### TCP协议

tcp协议又称好人协议，只要收到请求，就会发出一个确认信息。这也是从安全性的角度出发产生的一个'漏洞'。

**tcp报文**

![image.png](https://raw.githubusercontent.com/weirenhao/friendly-image/master/20241202094313.png)

tcp协议又称可靠协议：**tcp的请求确认机制是保证数据安全的原因，但这是一牺牲数据传输效率为代价的。**

**三次握手**

```python
<1> 客户端作为主动方，首先向服务端发一个建立链接的请求。
<2> 服务端接收到请求后，回复同意。
<3> 然后服务端也要向客户端发一个请求建立链接。
<4> 客户端收到请求后，回复同意
<2>和<3>是两个连续从服务端发出的消息，可以合并从一个回复并请求。整个过程就是三次握手建立TCP连接
```

**握手流程分析**：

- <1> 起初，TCP客户端A和TCP服务端B都处于关闭状态(CLOSED)。注意：A主动打开连接，B被动打开链接。
- <2> 服务端B先启动，准备接收客户端的连接请求，然后服务端就进入监听状态(LISTEN)，等待客户端的连接请求。
- <3> 客户端A启动，向B发出连接请求报文段，此时A进入SYN-SENT状态。
- <4> B收到连接请求后，如同意建立连接，则向A发送确认。同时也发送一个报文请求段，注意此时服务端不能携带数据。 服务端进入SYN-RCVD状态。
- <5> 客户端A收到B的确认后，还要向B给出确认。TCP规定此时报文段可以携带数据。但如果不携带数据时不会消耗一个序 号，在这种情况下，下一个数据报文段的序号仍是seq=x+1。这时，TCP连接已经建立，A进入ESTABLISHED状态。
- <6> 等B收到A的确认后，也进入ESTABLISHED状态。

```python
# 上面给出的建立连接的过程叫做三次握手（three-way handshake）。
# 客户端A最后一次还要再发送一次确认是有必要的，这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。

# 正常情况下：
服务端会大多数时间处在LISTEN状态，有正常客户端进来时，会瞬间经历SYN-RCVD状态快速到ESTABLISHED，等数据发送结束后又进入LISTEN状态。
客户端在SYN-SENT状态的时间非常短，多数处于入ESTABLISHED状态，断开与服务端连接后不再是ESTABLISHED状态。

# 非正常客户端：SYN-洪水攻击,模拟大量假的客户端向服务端发请求，占用服务端的资源，正常的客户端就进不去。
服务端大量处于：SYN-RCVD状态可能处于洪水攻击，也可能处于大并发状态。
当触发洪水攻击时，服务端也不会一直处于SYN-RCVD状态，但会浪费大量的时间在此处。
```

**补充：SYN-洪水攻击**

```python
非法分子模拟大量假的客户端给服务端发一个消息就跑了，然后服务端浪费大量时间在SYN-RCVD等待状态，严重占用正常客户端的访问。
```

**补充：半连接池**

```python
tcp协议有一个半连接池的概念，又称backlog。它的本质是一个队列，队列的大小一般为5-10个
它的目的是为了让服务端起到缓冲的作用。当客户端的请求过多时，请求先到半连接池等待服务端的挨个处理。
一边处理请求，一般新的请求再依次进入半连接池。
半连接池无法解决SYN-洪水攻击。
```

**数据传输**（来自掘金网：[https://juejin.im/post/5cb93204f265da039955d770#heading-2）](https://juejin.im/post/5cb93204f265da039955d770#heading-2%EF%BC%89)

- 客户端喊了一句话(data)，接收方听见了之后要回复自己听见了(ack)。如果喊了一句，半天没听到对方回复，就认为自己的话被大风吹走了，没听见，所以需要重新喊话，**这就是tcp重传**。也有可能是服务端听到了客户端的话，但是Server向Client的回复被大风吹走了，以至于Client没听见Server的回复。Client并不能判断究竟是自己的话被大风吹走了还是Server的回复被大风吹走了，Client也不用管，重传一下就是。

- Client可以向Server喊话，同样Server也可以向Client喊话，因为tcp链接是「双工的」，双方都可以主动发起数据传输。不过无论是哪方喊话，都需要收到对方的确认才能认为对方收到了自己的喊话。

- Client可能是个高射炮，一说连说了八句话，这时候Server可以不用一句一句回复，而是连续听了这八句话之后，一起向对方回复说前面你说的八句话我都听见了，这就是批量ack。但是Client也不能一次性说了太多话，Server的脑子短时间可能无法消化太多，两人之间需要有协商好的合适的发送和接受速率，这个就是「TCP窗口大小」。

**四次挥手**

关闭TCP连接。这是A进入终止状态1状态（FIN-WAIT-1），等待B的确认。注意，TCP规定FIN报文即 使不携带数据，也要消耗一个序号。即此时的u是上一次字节序号加1。

- <2> B收到连接释放报文段后即发出确认。然后B进入关闭等待状态（CLOSE-WAIT）。这时TCP连接处于半关闭状态（half-close），即A已经没有数据要发了，但若B发送数据，A仍要接收。也就是说从B到A这个方向的连接没有关闭，这个状态要持续到B给A发送完所有数据后。
- <3> A收到来自B的确认后，进入终止等待2状态（FIN-WAIT-2），等待B发出连接释放报文段。
- <4> 若B发完数据，就会发释放连接FIN报文段。B还必须重复上次发过的确认好ack=u+1。这时B进入最后确认状态（LAST-ACK），等待A的确认。
- <5> A收到B的连接释放报文段后，必须对此发出确认。然后进入时间等待状态（TIME-WAIT）。
- <6> B收到A的确认信息后，按照步骤进入关闭状态（CLOSED）。
- <7> 注意, 此时TCP连接还没有释放掉。A必须经过时间等待计时器（TIME-WAIT timer）设置的时间2MSL后, A才进入CLOSED状态。

```python
# 补充，A必须在TIME-WAIT状态下等待2MSL。目的有两个：
- 第一是保证A先进入CLOSED状态；
- 第二是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。
# B只要收到了A发出来的确认，就进入CLOSED状态。A必须等待2MSL。这就表明，B结束TCP连接的时间要比A早一些，这是提前结束连接的代价。
# 现实中，一般服务器要处理多个客户端用户，所以服务端一般处理完一个客户端的请求就会主动终止TCP连接，服务端多事4次挥手的发起者。
# 当服务端大量处于TIME-WAIT状态，意味着服务端正在经历高并发。
```

### UDP协议

udp协议特点：

- UDP是无连接的，即发数据之前不需要建立连接，同理发送数据结束也没有连接可释放，这极大减少了开销和发送数据之前的时延。
- UDP不保证数据的可靠交付，只负责将数据尽可能快的发出去。

---

## 应用层

应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 。

应用层功能：规定应用程序的数据格式。

例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。应用层也可以自定义协议。

```python
可以自定义协议 ---> 头部 + 数据部分
自定义协议需要注意的问题：
1、两大组成部分 = 头部 + 数据部分
	头部：放对数据的描述信息。比如：数据要发给谁，数据的类型，数据的长度
	数据部分：想要发的数据
2、头部的长度必须固定
	因为接收端要通过头部获取所接接收数据的详细信息
```

![image.png](https://raw.githubusercontent.com/weirenhao/friendly-image/master/20241202094410.png)

我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。

能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。

![image.png](https://raw.githubusercontent.com/weirenhao/friendly-image/master/20241202094426.png)

socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种"打开—读/写—关闭"模式的实现，服务器和客户端各自维护一个"文件"，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。

**总结**

![image.png](https://raw.githubusercontent.com/weirenhao/friendly-image/master/20241202094444.png)

**每层都有自己的协议**

![image.png](https://raw.githubusercontent.com/weirenhao/friendly-image/master/20241202094501.png)

## 网络通信实现

想实现网络通信，每台主机需具备四要素：

- 本机的IP地址
- 子网掩码
- 网关的IP地址
- DNS的IP地址

获取这四要素分两种方式：

- 静态获取：即手动配置

- 动态获取：通过dhcp协议动态获取相关ip参数。dhcp采用udp协议交互。

  ```python
  # dhcp数据包的格式
  以太网头 --> ip头 --> udp头 --> dhcp数据包
  # 每个头的内容
  <1> 最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。
  前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。
  <2> 后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。
  于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。
  <3> 最后的”UDP标头”，设置发出方的端口和接收方的端口。
  这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。过程分析
  ```

**dhcp动态获取主机相关ip参数的过程分析**：

- 这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。
- 因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。
- DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。
- 这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。
- 新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数

**DNS协议**

DNS是域名解析服务器。也可以是域名解析系统，是用来绑定ip和域名的关系，它基于udp协议。

```python
# 不管是BS架构还是CS架构的互联网通信软件都是基于IP地址+端口工作的。
# 对于BS架构，从方便使用者的角度出发(不需要用户记住复杂无趣的ip，引入的域名的概念)。于是BS软件就需要DNS域名解析过程。
# 基于CS架构的软件不需要DNS。
```

[IP地址，子网掩码，默认网关，DNS服务器详解](https://www.cnblogs.com/JuneWang/p/3917697.html)

![image.png](https://raw.githubusercontent.com/weirenhao/friendly-image/master/20241202094526.png)

```python
13台根dns：
A.root-servers.net198.41.0.4美国
B.root-servers.net192.228.79.201美国（另支持IPv6）
C.root-servers.net192.33.4.12法国
D.root-servers.net128.8.10.90美国
E.root-servers.net192.203.230.10美国
F.root-servers.net192.5.5.241美国（另支持IPv6）
G.root-servers.net192.112.36.4美国
H.root-servers.net128.63.2.53美国（另支持IPv6）
I.root-servers.net192.36.148.17瑞典
J.root-servers.net192.58.128.30美国
K.root-servers.net193.0.14.129英国（另支持IPv6）
L.root-servers.net198.32.64.12美国
M.root-servers.net202.12.27.33日本（另支持IPv6）

 
域名定义：http://jingyan.baidu.com/article/1974b289a649daf4b1f774cb.html
顶级域名：以.com,.net,.org,.cn等等属于国际顶级域名，根据目前的国际互联网域名体系，国际顶级域名分为两类：类别顶级域名(gTLD)和地理顶级域名(ccTLD)两种。类别顶级域名是　　　　　　　　            以"COM"、"NET"、"ORG"、"BIZ"、"INFO"等结尾的域名，均由国外公司负责管理。地理顶级域名是以国家或地区代码为结尾的域名，如"CN"代表中国，"UK"代表英国。地理顶级域名一般由各个国家或地区负责管理。

二级域名：二级域名是以顶级域名为基础的地理域名，比喻中国的二级域有，.com.cn,.net.cn,.org.cn,.gd.cn等.子域名是其父域名的子域名，比喻父域名是abc.com,子域名就是www.abc.com或者*.abc.com.
一般来说，二级域名是域名的一条记录，比如alidiedie.com是一个域名，www.alidiedie.com是其中比较常用的记录，一般默认是用这个，但是类似*.alidiedie.com的域名全部称作是alidiedie.com的二级
```

---

## 网络通信流程

1.本机获取

- 本机的IP地址：192.168.1.100
- 子网掩码：255.255.255.0
- 网关的IP地址：192.168.1.1
- DNS的IP地址：8.8.8.8

2.打开浏览器，想要访问Google，在地址栏输入了网址：[www.google.com。](http://www.google.com。)

3.dns协议(基于udp协议)

4.HTTP部分的内容，类似于下面这样。我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。

> GET / HTTP/1.1\
> Host: [www.google.com](http://www.google.com)\
> Connection: keep-alive\
> User-Agent: Mozilla/5.0 (Windows NT 6.1) ……\
> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,_/_;q=0.8\
> Accept-Encoding: gzip,deflate,sdch\
> Accept-Language: zh-CN,zh;q=0.8\
> Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3\
> Cookie: … …

5.TCP协议

TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。

6.IP协议

然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。

7.以太网协议

最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。

![image.png](https://raw.githubusercontent.com/weirenhao/friendly-image/master/20241202094545.png)

8.服务器端响应

经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。

本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。

---

## 网络通信流程总结2

基于网络通信的软件有两种：BS架构、CS架构。不同之处在于BS架构没有客户端软件，它依赖浏览器（特殊的客户端）。

在网络通信流程方面的不同之处在于，BS架构的软件在客户端（浏览器网址输入栏）多一个DNS域名解析过程。

在浏览器的网址输入栏上输入一个网址，按回车键到获取页面响应信息发生了：

```python
<1> 本机的DNS域名解析系统启动，获取域名对应的ip地址交给浏览器。
<2> TCP/IP封包过程，主要将浏览器输入栏中的虚拟路径和其他信息作为基本数据依次打包。
<3> 通过网络传输到对方主机，依次解包，对方主机应用层软件获取这个虚拟路径对应的资源，原路返回响应给客户端。
<4> 本地主机接收到响应信息，依次解包，获取请求的资源。
<5> 至此完成一次网络通信交流流程。
```

客户端的数据包装结构：

```python
比如我们访问百度：https://www.cnblogs.com/the3times/p/12715643.html
```

- 首先DNS协议启动工作，获取域名对应的ip
- 应用层将数据the3times/p/12715643.html打包一个https协议的协议头，将这个包交给传输层。
- 传输层基于TCP协议，将应用层下交的数据再打包一个tcp头，这个头包含自己浏览器的端口和对方主机的端口。再将数据交给网络层。
- 网络层拿到数据后，再打包一个ip头，包含自己主机的ip和对方主机的ip。将包裹下交给数据链路层。
- 数据链路层拿到数据后，发现两个ip地址的网络地址不同，判断是外网的ip，就会在整个包裹上再打包一个以太网头。这个以太网头主要是自己主机的mac地址和当前局域网网关的mac地址。
- 物理层拿到数据后，转为二进制01数据，通过网络传输送到对方局域网的网关（这中间经过交互机、路由系统等），根据ip地址找到主机(arp协议)，再根据端口号找到软件，再根据url路径找到资源。
- 然后对方主机返回响应数据，按原路返回资源。我方接受到响应资源后就完成了一次网络通信。
